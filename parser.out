Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT
    DO
    DOT
    DOWNTO
    FALSE
    FUNCTION
    NOT
    PROCEDURE
    TO
    TRUE

Grammar

Rule 0     S' -> file
Rule 1     file -> PROGRAM name vars code
Rule 2     name -> IDENTIFIER SEMICOLON
Rule 3     vars -> VAR varstail
Rule 4     vars -> empty
Rule 5     varstail -> vardecl varstail
Rule 6     varstail -> empty
Rule 7     vardecl -> idlist COLON type SEMICOLON
Rule 8     idlist -> IDENTIFIER idlistTail
Rule 9     idlistTail -> COMMA IDENTIFIER idlistTail
Rule 10    idlistTail -> empty
Rule 11    type -> TYPE_INTEGER
Rule 12    type -> TYPE_REAL
Rule 13    type -> BOOLEAN
Rule 14    type -> TYPE_STRING
Rule 15    type -> ARRAY LBRACKET INTEGER RBRACKET OF type
Rule 16    code -> BEGIN expressions END
Rule 17    expressions -> statement expressions_tail
Rule 18    expressions -> empty
Rule 19    expressions_tail -> SEMICOLON expressions
Rule 20    expressions_tail -> empty
Rule 21    statement -> IDENTIFIER ASSIGN assign_expression
Rule 22    statement -> WRITELN write_statement
Rule 23    statement -> WRITE write_statement
Rule 24    statement -> READLN readln_statement
Rule 25    statement -> IF if_condition THEN if_code
Rule 26    statement -> FOR
Rule 27    statement -> WHILE
Rule 28    if_code -> code opt_else
Rule 29    if_code -> statement opt_else
Rule 30    if_code -> empty
Rule 31    opt_else -> ELSE code_or_statement
Rule 32    opt_else -> empty
Rule 33    code_or_statement -> code
Rule 34    code_or_statement -> statement
Rule 35    if_condition -> expression if_condition_tail
Rule 36    if_condition_tail -> OR if_condition_tail_2
Rule 37    if_condition_tail -> if_condition_tail_2
Rule 38    if_condition_tail_2 -> AND if_condition
Rule 39    if_condition_tail_2 -> empty
Rule 40    write_statement -> LPAREN string_statement RPAREN
Rule 41    readln_statement -> LPAREN string_statement RPAREN
Rule 42    string_statement -> assign_expression
Rule 43    string_statement -> assign_expression COMMA string_statement
Rule 44    assign_expression -> expression
Rule 45    assign_expression -> STRING
Rule 46    expression -> expression OR and_expression
Rule 47    expression -> and_expression
Rule 48    and_expression -> and_expression AND relation_expression
Rule 49    and_expression -> relation_expression
Rule 50    relation_expression -> simple_expression expression_tail
Rule 51    expression_tail -> LT simple_expression
Rule 52    expression_tail -> GT simple_expression
Rule 53    expression_tail -> LE simple_expression
Rule 54    expression_tail -> GE simple_expression
Rule 55    expression_tail -> NE simple_expression
Rule 56    expression_tail -> EQUAL simple_expression
Rule 57    expression_tail -> empty
Rule 58    simple_expression -> term simple_expression_tail
Rule 59    simple_expression_tail -> PLUS term simple_expression_tail
Rule 60    simple_expression_tail -> MINUS term simple_expression_tail
Rule 61    simple_expression_tail -> empty
Rule 62    term -> factor term_tail
Rule 63    term_tail -> TIMES factor term_tail
Rule 64    term_tail -> DIVIDE factor term_tail
Rule 65    term_tail -> REAL_DIVIDE factor term_tail
Rule 66    term_tail -> empty
Rule 67    factor -> PLUS factor
Rule 68    factor -> MINUS factor
Rule 69    factor -> LPAREN expression RPAREN
Rule 70    factor -> INTEGER
Rule 71    factor -> REAL
Rule 72    factor -> IDENTIFIER
Rule 73    empty -> <empty>

Terminals, with rules where they appear

AND                  : 38 48
ARRAY                : 15
ASSIGN               : 21
BEGIN                : 16
BOOLEAN              : 13
COLON                : 7
COMMA                : 9 43
COMMENT              : 
DIVIDE               : 64
DO                   : 
DOT                  : 
DOWNTO               : 
ELSE                 : 31
END                  : 16
EQUAL                : 56
FALSE                : 
FOR                  : 26
FUNCTION             : 
GE                   : 54
GT                   : 52
IDENTIFIER           : 2 8 9 21 72
IF                   : 25
INTEGER              : 15 70
LBRACKET             : 15
LE                   : 53
LPAREN               : 40 41 69
LT                   : 51
MINUS                : 60 68
NE                   : 55
NOT                  : 
OF                   : 15
OR                   : 36 46
PLUS                 : 59 67
PROCEDURE            : 
PROGRAM              : 1
RBRACKET             : 15
READLN               : 24
REAL                 : 71
REAL_DIVIDE          : 65
RPAREN               : 40 41 69
SEMICOLON            : 2 7 19
STRING               : 45
THEN                 : 25
TIMES                : 63
TO                   : 
TRUE                 : 
TYPE_INTEGER         : 11
TYPE_REAL            : 12
TYPE_STRING          : 14
VAR                  : 3
WHILE                : 27
WRITE                : 23
WRITELN              : 22
error                : 

Nonterminals, with rules where they appear

and_expression       : 46 47 48
assign_expression    : 21 42 43
code                 : 1 28 33
code_or_statement    : 31
empty                : 4 6 10 18 20 30 32 39 57 61 66
expression           : 35 44 46 69
expression_tail      : 50
expressions          : 16 19
expressions_tail     : 17
factor               : 62 63 64 65 67 68
file                 : 0
idlist               : 7
idlistTail           : 8 9
if_code              : 25
if_condition         : 25 38
if_condition_tail    : 35
if_condition_tail_2  : 36 37
name                 : 1
opt_else             : 28 29
readln_statement     : 24
relation_expression  : 48 49
simple_expression    : 50 51 52 53 54 55 56
simple_expression_tail : 58 59 60
statement            : 17 29 34
string_statement     : 40 41 43
term                 : 58 59 60
term_tail            : 62 63 64 65
type                 : 7 15
vardecl              : 5
vars                 : 1
varstail             : 3 5
write_statement      : 22 23

Parsing method: LALR

state 0

    (0) S' -> . file
    (1) file -> . PROGRAM name vars code

    PROGRAM         shift and go to state 2

    file                           shift and go to state 1

state 1

    (0) S' -> file .



state 2

    (1) file -> PROGRAM . name vars code
    (2) name -> . IDENTIFIER SEMICOLON

    IDENTIFIER      shift and go to state 4

    name                           shift and go to state 3

state 3

    (1) file -> PROGRAM name . vars code
    (3) vars -> . VAR varstail
    (4) vars -> . empty
    (73) empty -> .

    VAR             shift and go to state 6
    BEGIN           reduce using rule 73 (empty -> .)

    vars                           shift and go to state 5
    empty                          shift and go to state 7

state 4

    (2) name -> IDENTIFIER . SEMICOLON

    SEMICOLON       shift and go to state 8


state 5

    (1) file -> PROGRAM name vars . code
    (16) code -> . BEGIN expressions END

    BEGIN           shift and go to state 10

    code                           shift and go to state 9

state 6

    (3) vars -> VAR . varstail
    (5) varstail -> . vardecl varstail
    (6) varstail -> . empty
    (7) vardecl -> . idlist COLON type SEMICOLON
    (73) empty -> .
    (8) idlist -> . IDENTIFIER idlistTail

    BEGIN           reduce using rule 73 (empty -> .)
    IDENTIFIER      shift and go to state 15

    varstail                       shift and go to state 11
    vardecl                        shift and go to state 12
    empty                          shift and go to state 13
    idlist                         shift and go to state 14

state 7

    (4) vars -> empty .

    BEGIN           reduce using rule 4 (vars -> empty .)


state 8

    (2) name -> IDENTIFIER SEMICOLON .

    VAR             reduce using rule 2 (name -> IDENTIFIER SEMICOLON .)
    BEGIN           reduce using rule 2 (name -> IDENTIFIER SEMICOLON .)


state 9

    (1) file -> PROGRAM name vars code .

    $end            reduce using rule 1 (file -> PROGRAM name vars code .)


state 10

    (16) code -> BEGIN . expressions END
    (17) expressions -> . statement expressions_tail
    (18) expressions -> . empty
    (21) statement -> . IDENTIFIER ASSIGN assign_expression
    (22) statement -> . WRITELN write_statement
    (23) statement -> . WRITE write_statement
    (24) statement -> . READLN readln_statement
    (25) statement -> . IF if_condition THEN if_code
    (26) statement -> . FOR
    (27) statement -> . WHILE
    (73) empty -> .

    IDENTIFIER      shift and go to state 19
    WRITELN         shift and go to state 20
    WRITE           shift and go to state 21
    READLN          shift and go to state 22
    IF              shift and go to state 23
    FOR             shift and go to state 24
    WHILE           shift and go to state 25
    END             reduce using rule 73 (empty -> .)

    expressions                    shift and go to state 16
    statement                      shift and go to state 17
    empty                          shift and go to state 18

state 11

    (3) vars -> VAR varstail .

    BEGIN           reduce using rule 3 (vars -> VAR varstail .)


state 12

    (5) varstail -> vardecl . varstail
    (5) varstail -> . vardecl varstail
    (6) varstail -> . empty
    (7) vardecl -> . idlist COLON type SEMICOLON
    (73) empty -> .
    (8) idlist -> . IDENTIFIER idlistTail

    BEGIN           reduce using rule 73 (empty -> .)
    IDENTIFIER      shift and go to state 15

    vardecl                        shift and go to state 12
    varstail                       shift and go to state 26
    empty                          shift and go to state 13
    idlist                         shift and go to state 14

state 13

    (6) varstail -> empty .

    BEGIN           reduce using rule 6 (varstail -> empty .)


state 14

    (7) vardecl -> idlist . COLON type SEMICOLON

    COLON           shift and go to state 27


state 15

    (8) idlist -> IDENTIFIER . idlistTail
    (9) idlistTail -> . COMMA IDENTIFIER idlistTail
    (10) idlistTail -> . empty
    (73) empty -> .

    COMMA           shift and go to state 29
    COLON           reduce using rule 73 (empty -> .)

    idlistTail                     shift and go to state 28
    empty                          shift and go to state 30

state 16

    (16) code -> BEGIN expressions . END

    END             shift and go to state 31


state 17

    (17) expressions -> statement . expressions_tail
    (19) expressions_tail -> . SEMICOLON expressions
    (20) expressions_tail -> . empty
    (73) empty -> .

    SEMICOLON       shift and go to state 33
    END             reduce using rule 73 (empty -> .)

    expressions_tail               shift and go to state 32
    empty                          shift and go to state 34

state 18

    (18) expressions -> empty .

    END             reduce using rule 18 (expressions -> empty .)


state 19

    (21) statement -> IDENTIFIER . ASSIGN assign_expression

    ASSIGN          shift and go to state 35


state 20

    (22) statement -> WRITELN . write_statement
    (40) write_statement -> . LPAREN string_statement RPAREN

    LPAREN          shift and go to state 37

    write_statement                shift and go to state 36

state 21

    (23) statement -> WRITE . write_statement
    (40) write_statement -> . LPAREN string_statement RPAREN

    LPAREN          shift and go to state 37

    write_statement                shift and go to state 38

state 22

    (24) statement -> READLN . readln_statement
    (41) readln_statement -> . LPAREN string_statement RPAREN

    LPAREN          shift and go to state 40

    readln_statement               shift and go to state 39

state 23

    (25) statement -> IF . if_condition THEN if_code
    (35) if_condition -> . expression if_condition_tail
    (46) expression -> . expression OR and_expression
    (47) expression -> . and_expression
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    if_condition                   shift and go to state 41
    expression                     shift and go to state 42
    and_expression                 shift and go to state 43
    relation_expression            shift and go to state 44
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 24

    (26) statement -> FOR .

    SEMICOLON       reduce using rule 26 (statement -> FOR .)
    END             reduce using rule 26 (statement -> FOR .)
    ELSE            reduce using rule 26 (statement -> FOR .)


state 25

    (27) statement -> WHILE .

    SEMICOLON       reduce using rule 27 (statement -> WHILE .)
    END             reduce using rule 27 (statement -> WHILE .)
    ELSE            reduce using rule 27 (statement -> WHILE .)


state 26

    (5) varstail -> vardecl varstail .

    BEGIN           reduce using rule 5 (varstail -> vardecl varstail .)


state 27

    (7) vardecl -> idlist COLON . type SEMICOLON
    (11) type -> . TYPE_INTEGER
    (12) type -> . TYPE_REAL
    (13) type -> . BOOLEAN
    (14) type -> . TYPE_STRING
    (15) type -> . ARRAY LBRACKET INTEGER RBRACKET OF type

    TYPE_INTEGER    shift and go to state 55
    TYPE_REAL       shift and go to state 56
    BOOLEAN         shift and go to state 57
    TYPE_STRING     shift and go to state 58
    ARRAY           shift and go to state 59

    type                           shift and go to state 54

state 28

    (8) idlist -> IDENTIFIER idlistTail .

    COLON           reduce using rule 8 (idlist -> IDENTIFIER idlistTail .)


state 29

    (9) idlistTail -> COMMA . IDENTIFIER idlistTail

    IDENTIFIER      shift and go to state 60


state 30

    (10) idlistTail -> empty .

    COLON           reduce using rule 10 (idlistTail -> empty .)


state 31

    (16) code -> BEGIN expressions END .

    $end            reduce using rule 16 (code -> BEGIN expressions END .)
    ELSE            reduce using rule 16 (code -> BEGIN expressions END .)
    SEMICOLON       reduce using rule 16 (code -> BEGIN expressions END .)
    END             reduce using rule 16 (code -> BEGIN expressions END .)


state 32

    (17) expressions -> statement expressions_tail .

    END             reduce using rule 17 (expressions -> statement expressions_tail .)


state 33

    (19) expressions_tail -> SEMICOLON . expressions
    (17) expressions -> . statement expressions_tail
    (18) expressions -> . empty
    (21) statement -> . IDENTIFIER ASSIGN assign_expression
    (22) statement -> . WRITELN write_statement
    (23) statement -> . WRITE write_statement
    (24) statement -> . READLN readln_statement
    (25) statement -> . IF if_condition THEN if_code
    (26) statement -> . FOR
    (27) statement -> . WHILE
    (73) empty -> .

    IDENTIFIER      shift and go to state 19
    WRITELN         shift and go to state 20
    WRITE           shift and go to state 21
    READLN          shift and go to state 22
    IF              shift and go to state 23
    FOR             shift and go to state 24
    WHILE           shift and go to state 25
    END             reduce using rule 73 (empty -> .)

    expressions                    shift and go to state 61
    statement                      shift and go to state 17
    empty                          shift and go to state 18

state 34

    (20) expressions_tail -> empty .

    END             reduce using rule 20 (expressions_tail -> empty .)


state 35

    (21) statement -> IDENTIFIER ASSIGN . assign_expression
    (44) assign_expression -> . expression
    (45) assign_expression -> . STRING
    (46) expression -> . expression OR and_expression
    (47) expression -> . and_expression
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    STRING          shift and go to state 64
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    assign_expression              shift and go to state 62
    expression                     shift and go to state 63
    and_expression                 shift and go to state 43
    relation_expression            shift and go to state 44
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 36

    (22) statement -> WRITELN write_statement .

    SEMICOLON       reduce using rule 22 (statement -> WRITELN write_statement .)
    END             reduce using rule 22 (statement -> WRITELN write_statement .)
    ELSE            reduce using rule 22 (statement -> WRITELN write_statement .)


state 37

    (40) write_statement -> LPAREN . string_statement RPAREN
    (42) string_statement -> . assign_expression
    (43) string_statement -> . assign_expression COMMA string_statement
    (44) assign_expression -> . expression
    (45) assign_expression -> . STRING
    (46) expression -> . expression OR and_expression
    (47) expression -> . and_expression
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    STRING          shift and go to state 64
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    string_statement               shift and go to state 65
    assign_expression              shift and go to state 66
    expression                     shift and go to state 63
    and_expression                 shift and go to state 43
    relation_expression            shift and go to state 44
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 38

    (23) statement -> WRITE write_statement .

    SEMICOLON       reduce using rule 23 (statement -> WRITE write_statement .)
    END             reduce using rule 23 (statement -> WRITE write_statement .)
    ELSE            reduce using rule 23 (statement -> WRITE write_statement .)


state 39

    (24) statement -> READLN readln_statement .

    SEMICOLON       reduce using rule 24 (statement -> READLN readln_statement .)
    END             reduce using rule 24 (statement -> READLN readln_statement .)
    ELSE            reduce using rule 24 (statement -> READLN readln_statement .)


state 40

    (41) readln_statement -> LPAREN . string_statement RPAREN
    (42) string_statement -> . assign_expression
    (43) string_statement -> . assign_expression COMMA string_statement
    (44) assign_expression -> . expression
    (45) assign_expression -> . STRING
    (46) expression -> . expression OR and_expression
    (47) expression -> . and_expression
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    STRING          shift and go to state 64
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    string_statement               shift and go to state 67
    assign_expression              shift and go to state 66
    expression                     shift and go to state 63
    and_expression                 shift and go to state 43
    relation_expression            shift and go to state 44
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 41

    (25) statement -> IF if_condition . THEN if_code

    THEN            shift and go to state 68


state 42

    (35) if_condition -> expression . if_condition_tail
    (46) expression -> expression . OR and_expression
    (36) if_condition_tail -> . OR if_condition_tail_2
    (37) if_condition_tail -> . if_condition_tail_2
    (38) if_condition_tail_2 -> . AND if_condition
    (39) if_condition_tail_2 -> . empty
    (73) empty -> .

    OR              shift and go to state 70
    AND             shift and go to state 72
    THEN            reduce using rule 73 (empty -> .)

    if_condition_tail              shift and go to state 69
    if_condition_tail_2            shift and go to state 71
    empty                          shift and go to state 73

state 43

    (47) expression -> and_expression .
    (48) and_expression -> and_expression . AND relation_expression

  ! shift/reduce conflict for AND resolved as shift
    OR              reduce using rule 47 (expression -> and_expression .)
    THEN            reduce using rule 47 (expression -> and_expression .)
    SEMICOLON       reduce using rule 47 (expression -> and_expression .)
    END             reduce using rule 47 (expression -> and_expression .)
    ELSE            reduce using rule 47 (expression -> and_expression .)
    COMMA           reduce using rule 47 (expression -> and_expression .)
    RPAREN          reduce using rule 47 (expression -> and_expression .)
    AND             shift and go to state 74

  ! AND             [ reduce using rule 47 (expression -> and_expression .) ]


state 44

    (49) and_expression -> relation_expression .

    AND             reduce using rule 49 (and_expression -> relation_expression .)
    OR              reduce using rule 49 (and_expression -> relation_expression .)
    THEN            reduce using rule 49 (and_expression -> relation_expression .)
    SEMICOLON       reduce using rule 49 (and_expression -> relation_expression .)
    END             reduce using rule 49 (and_expression -> relation_expression .)
    ELSE            reduce using rule 49 (and_expression -> relation_expression .)
    COMMA           reduce using rule 49 (and_expression -> relation_expression .)
    RPAREN          reduce using rule 49 (and_expression -> relation_expression .)


state 45

    (50) relation_expression -> simple_expression . expression_tail
    (51) expression_tail -> . LT simple_expression
    (52) expression_tail -> . GT simple_expression
    (53) expression_tail -> . LE simple_expression
    (54) expression_tail -> . GE simple_expression
    (55) expression_tail -> . NE simple_expression
    (56) expression_tail -> . EQUAL simple_expression
    (57) expression_tail -> . empty
    (73) empty -> .

    LT              shift and go to state 76
    GT              shift and go to state 77
    LE              shift and go to state 78
    GE              shift and go to state 79
    NE              shift and go to state 80
    EQUAL           shift and go to state 81
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    THEN            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)
    ELSE            reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    expression_tail                shift and go to state 75
    empty                          shift and go to state 82

state 46

    (58) simple_expression -> term . simple_expression_tail
    (59) simple_expression_tail -> . PLUS term simple_expression_tail
    (60) simple_expression_tail -> . MINUS term simple_expression_tail
    (61) simple_expression_tail -> . empty
    (73) empty -> .

    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    LT              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    NE              reduce using rule 73 (empty -> .)
    EQUAL           reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    THEN            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)
    ELSE            reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    simple_expression_tail         shift and go to state 83
    empty                          shift and go to state 86

state 47

    (62) term -> factor . term_tail
    (63) term_tail -> . TIMES factor term_tail
    (64) term_tail -> . DIVIDE factor term_tail
    (65) term_tail -> . REAL_DIVIDE factor term_tail
    (66) term_tail -> . empty
    (73) empty -> .

    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    REAL_DIVIDE     shift and go to state 90
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    NE              reduce using rule 73 (empty -> .)
    EQUAL           reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    THEN            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)
    ELSE            reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    term_tail                      shift and go to state 87
    empty                          shift and go to state 91

state 48

    (67) factor -> PLUS . factor
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    factor                         shift and go to state 92

state 49

    (68) factor -> MINUS . factor
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    factor                         shift and go to state 93

state 50

    (69) factor -> LPAREN . expression RPAREN
    (46) expression -> . expression OR and_expression
    (47) expression -> . and_expression
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    expression                     shift and go to state 94
    and_expression                 shift and go to state 43
    relation_expression            shift and go to state 44
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 51

    (70) factor -> INTEGER .

    TIMES           reduce using rule 70 (factor -> INTEGER .)
    DIVIDE          reduce using rule 70 (factor -> INTEGER .)
    REAL_DIVIDE     reduce using rule 70 (factor -> INTEGER .)
    PLUS            reduce using rule 70 (factor -> INTEGER .)
    MINUS           reduce using rule 70 (factor -> INTEGER .)
    LT              reduce using rule 70 (factor -> INTEGER .)
    GT              reduce using rule 70 (factor -> INTEGER .)
    LE              reduce using rule 70 (factor -> INTEGER .)
    GE              reduce using rule 70 (factor -> INTEGER .)
    NE              reduce using rule 70 (factor -> INTEGER .)
    EQUAL           reduce using rule 70 (factor -> INTEGER .)
    AND             reduce using rule 70 (factor -> INTEGER .)
    OR              reduce using rule 70 (factor -> INTEGER .)
    THEN            reduce using rule 70 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 70 (factor -> INTEGER .)
    END             reduce using rule 70 (factor -> INTEGER .)
    ELSE            reduce using rule 70 (factor -> INTEGER .)
    COMMA           reduce using rule 70 (factor -> INTEGER .)
    RPAREN          reduce using rule 70 (factor -> INTEGER .)


state 52

    (71) factor -> REAL .

    TIMES           reduce using rule 71 (factor -> REAL .)
    DIVIDE          reduce using rule 71 (factor -> REAL .)
    REAL_DIVIDE     reduce using rule 71 (factor -> REAL .)
    PLUS            reduce using rule 71 (factor -> REAL .)
    MINUS           reduce using rule 71 (factor -> REAL .)
    LT              reduce using rule 71 (factor -> REAL .)
    GT              reduce using rule 71 (factor -> REAL .)
    LE              reduce using rule 71 (factor -> REAL .)
    GE              reduce using rule 71 (factor -> REAL .)
    NE              reduce using rule 71 (factor -> REAL .)
    EQUAL           reduce using rule 71 (factor -> REAL .)
    AND             reduce using rule 71 (factor -> REAL .)
    OR              reduce using rule 71 (factor -> REAL .)
    THEN            reduce using rule 71 (factor -> REAL .)
    SEMICOLON       reduce using rule 71 (factor -> REAL .)
    END             reduce using rule 71 (factor -> REAL .)
    ELSE            reduce using rule 71 (factor -> REAL .)
    COMMA           reduce using rule 71 (factor -> REAL .)
    RPAREN          reduce using rule 71 (factor -> REAL .)


state 53

    (72) factor -> IDENTIFIER .

    TIMES           reduce using rule 72 (factor -> IDENTIFIER .)
    DIVIDE          reduce using rule 72 (factor -> IDENTIFIER .)
    REAL_DIVIDE     reduce using rule 72 (factor -> IDENTIFIER .)
    PLUS            reduce using rule 72 (factor -> IDENTIFIER .)
    MINUS           reduce using rule 72 (factor -> IDENTIFIER .)
    LT              reduce using rule 72 (factor -> IDENTIFIER .)
    GT              reduce using rule 72 (factor -> IDENTIFIER .)
    LE              reduce using rule 72 (factor -> IDENTIFIER .)
    GE              reduce using rule 72 (factor -> IDENTIFIER .)
    NE              reduce using rule 72 (factor -> IDENTIFIER .)
    EQUAL           reduce using rule 72 (factor -> IDENTIFIER .)
    AND             reduce using rule 72 (factor -> IDENTIFIER .)
    OR              reduce using rule 72 (factor -> IDENTIFIER .)
    THEN            reduce using rule 72 (factor -> IDENTIFIER .)
    SEMICOLON       reduce using rule 72 (factor -> IDENTIFIER .)
    END             reduce using rule 72 (factor -> IDENTIFIER .)
    ELSE            reduce using rule 72 (factor -> IDENTIFIER .)
    COMMA           reduce using rule 72 (factor -> IDENTIFIER .)
    RPAREN          reduce using rule 72 (factor -> IDENTIFIER .)


state 54

    (7) vardecl -> idlist COLON type . SEMICOLON

    SEMICOLON       shift and go to state 95


state 55

    (11) type -> TYPE_INTEGER .

    SEMICOLON       reduce using rule 11 (type -> TYPE_INTEGER .)


state 56

    (12) type -> TYPE_REAL .

    SEMICOLON       reduce using rule 12 (type -> TYPE_REAL .)


state 57

    (13) type -> BOOLEAN .

    SEMICOLON       reduce using rule 13 (type -> BOOLEAN .)


state 58

    (14) type -> TYPE_STRING .

    SEMICOLON       reduce using rule 14 (type -> TYPE_STRING .)


state 59

    (15) type -> ARRAY . LBRACKET INTEGER RBRACKET OF type

    LBRACKET        shift and go to state 96


state 60

    (9) idlistTail -> COMMA IDENTIFIER . idlistTail
    (9) idlistTail -> . COMMA IDENTIFIER idlistTail
    (10) idlistTail -> . empty
    (73) empty -> .

    COMMA           shift and go to state 29
    COLON           reduce using rule 73 (empty -> .)

    idlistTail                     shift and go to state 97
    empty                          shift and go to state 30

state 61

    (19) expressions_tail -> SEMICOLON expressions .

    END             reduce using rule 19 (expressions_tail -> SEMICOLON expressions .)


state 62

    (21) statement -> IDENTIFIER ASSIGN assign_expression .

    SEMICOLON       reduce using rule 21 (statement -> IDENTIFIER ASSIGN assign_expression .)
    END             reduce using rule 21 (statement -> IDENTIFIER ASSIGN assign_expression .)
    ELSE            reduce using rule 21 (statement -> IDENTIFIER ASSIGN assign_expression .)


state 63

    (44) assign_expression -> expression .
    (46) expression -> expression . OR and_expression

    SEMICOLON       reduce using rule 44 (assign_expression -> expression .)
    END             reduce using rule 44 (assign_expression -> expression .)
    ELSE            reduce using rule 44 (assign_expression -> expression .)
    COMMA           reduce using rule 44 (assign_expression -> expression .)
    RPAREN          reduce using rule 44 (assign_expression -> expression .)
    OR              shift and go to state 98


state 64

    (45) assign_expression -> STRING .

    SEMICOLON       reduce using rule 45 (assign_expression -> STRING .)
    END             reduce using rule 45 (assign_expression -> STRING .)
    ELSE            reduce using rule 45 (assign_expression -> STRING .)
    COMMA           reduce using rule 45 (assign_expression -> STRING .)
    RPAREN          reduce using rule 45 (assign_expression -> STRING .)


state 65

    (40) write_statement -> LPAREN string_statement . RPAREN

    RPAREN          shift and go to state 99


state 66

    (42) string_statement -> assign_expression .
    (43) string_statement -> assign_expression . COMMA string_statement

    RPAREN          reduce using rule 42 (string_statement -> assign_expression .)
    COMMA           shift and go to state 100


state 67

    (41) readln_statement -> LPAREN string_statement . RPAREN

    RPAREN          shift and go to state 101


state 68

    (25) statement -> IF if_condition THEN . if_code
    (28) if_code -> . code opt_else
    (29) if_code -> . statement opt_else
    (30) if_code -> . empty
    (16) code -> . BEGIN expressions END
    (21) statement -> . IDENTIFIER ASSIGN assign_expression
    (22) statement -> . WRITELN write_statement
    (23) statement -> . WRITE write_statement
    (24) statement -> . READLN readln_statement
    (25) statement -> . IF if_condition THEN if_code
    (26) statement -> . FOR
    (27) statement -> . WHILE
    (73) empty -> .

    BEGIN           shift and go to state 10
    IDENTIFIER      shift and go to state 19
    WRITELN         shift and go to state 20
    WRITE           shift and go to state 21
    READLN          shift and go to state 22
    IF              shift and go to state 23
    FOR             shift and go to state 24
    WHILE           shift and go to state 25
    ELSE            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)

    if_code                        shift and go to state 102
    code                           shift and go to state 103
    statement                      shift and go to state 104
    empty                          shift and go to state 105

state 69

    (35) if_condition -> expression if_condition_tail .

    THEN            reduce using rule 35 (if_condition -> expression if_condition_tail .)


state 70

    (46) expression -> expression OR . and_expression
    (36) if_condition_tail -> OR . if_condition_tail_2
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (38) if_condition_tail_2 -> . AND if_condition
    (39) if_condition_tail_2 -> . empty
    (50) relation_expression -> . simple_expression expression_tail
    (73) empty -> .
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    AND             shift and go to state 72
    THEN            reduce using rule 73 (empty -> .)
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    and_expression                 shift and go to state 106
    if_condition_tail_2            shift and go to state 107
    relation_expression            shift and go to state 44
    empty                          shift and go to state 73
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 71

    (37) if_condition_tail -> if_condition_tail_2 .

    THEN            reduce using rule 37 (if_condition_tail -> if_condition_tail_2 .)


state 72

    (38) if_condition_tail_2 -> AND . if_condition
    (35) if_condition -> . expression if_condition_tail
    (46) expression -> . expression OR and_expression
    (47) expression -> . and_expression
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    if_condition                   shift and go to state 108
    expression                     shift and go to state 42
    and_expression                 shift and go to state 43
    relation_expression            shift and go to state 44
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 73

    (39) if_condition_tail_2 -> empty .

    THEN            reduce using rule 39 (if_condition_tail_2 -> empty .)


state 74

    (48) and_expression -> and_expression AND . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    relation_expression            shift and go to state 109
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 75

    (50) relation_expression -> simple_expression expression_tail .

    AND             reduce using rule 50 (relation_expression -> simple_expression expression_tail .)
    OR              reduce using rule 50 (relation_expression -> simple_expression expression_tail .)
    THEN            reduce using rule 50 (relation_expression -> simple_expression expression_tail .)
    SEMICOLON       reduce using rule 50 (relation_expression -> simple_expression expression_tail .)
    END             reduce using rule 50 (relation_expression -> simple_expression expression_tail .)
    ELSE            reduce using rule 50 (relation_expression -> simple_expression expression_tail .)
    COMMA           reduce using rule 50 (relation_expression -> simple_expression expression_tail .)
    RPAREN          reduce using rule 50 (relation_expression -> simple_expression expression_tail .)


state 76

    (51) expression_tail -> LT . simple_expression
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    simple_expression              shift and go to state 110
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 77

    (52) expression_tail -> GT . simple_expression
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    simple_expression              shift and go to state 111
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 78

    (53) expression_tail -> LE . simple_expression
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    simple_expression              shift and go to state 112
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 79

    (54) expression_tail -> GE . simple_expression
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    simple_expression              shift and go to state 113
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 80

    (55) expression_tail -> NE . simple_expression
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    simple_expression              shift and go to state 114
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 81

    (56) expression_tail -> EQUAL . simple_expression
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    simple_expression              shift and go to state 115
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 82

    (57) expression_tail -> empty .

    AND             reduce using rule 57 (expression_tail -> empty .)
    OR              reduce using rule 57 (expression_tail -> empty .)
    THEN            reduce using rule 57 (expression_tail -> empty .)
    SEMICOLON       reduce using rule 57 (expression_tail -> empty .)
    END             reduce using rule 57 (expression_tail -> empty .)
    ELSE            reduce using rule 57 (expression_tail -> empty .)
    COMMA           reduce using rule 57 (expression_tail -> empty .)
    RPAREN          reduce using rule 57 (expression_tail -> empty .)


state 83

    (58) simple_expression -> term simple_expression_tail .

    LT              reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    GT              reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    LE              reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    GE              reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    NE              reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    EQUAL           reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    AND             reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    OR              reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    THEN            reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    SEMICOLON       reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    END             reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    ELSE            reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    COMMA           reduce using rule 58 (simple_expression -> term simple_expression_tail .)
    RPAREN          reduce using rule 58 (simple_expression -> term simple_expression_tail .)


state 84

    (59) simple_expression_tail -> PLUS . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    term                           shift and go to state 116
    factor                         shift and go to state 47

state 85

    (60) simple_expression_tail -> MINUS . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    term                           shift and go to state 117
    factor                         shift and go to state 47

state 86

    (61) simple_expression_tail -> empty .

    LT              reduce using rule 61 (simple_expression_tail -> empty .)
    GT              reduce using rule 61 (simple_expression_tail -> empty .)
    LE              reduce using rule 61 (simple_expression_tail -> empty .)
    GE              reduce using rule 61 (simple_expression_tail -> empty .)
    NE              reduce using rule 61 (simple_expression_tail -> empty .)
    EQUAL           reduce using rule 61 (simple_expression_tail -> empty .)
    AND             reduce using rule 61 (simple_expression_tail -> empty .)
    OR              reduce using rule 61 (simple_expression_tail -> empty .)
    THEN            reduce using rule 61 (simple_expression_tail -> empty .)
    SEMICOLON       reduce using rule 61 (simple_expression_tail -> empty .)
    END             reduce using rule 61 (simple_expression_tail -> empty .)
    ELSE            reduce using rule 61 (simple_expression_tail -> empty .)
    COMMA           reduce using rule 61 (simple_expression_tail -> empty .)
    RPAREN          reduce using rule 61 (simple_expression_tail -> empty .)


state 87

    (62) term -> factor term_tail .

    PLUS            reduce using rule 62 (term -> factor term_tail .)
    MINUS           reduce using rule 62 (term -> factor term_tail .)
    LT              reduce using rule 62 (term -> factor term_tail .)
    GT              reduce using rule 62 (term -> factor term_tail .)
    LE              reduce using rule 62 (term -> factor term_tail .)
    GE              reduce using rule 62 (term -> factor term_tail .)
    NE              reduce using rule 62 (term -> factor term_tail .)
    EQUAL           reduce using rule 62 (term -> factor term_tail .)
    AND             reduce using rule 62 (term -> factor term_tail .)
    OR              reduce using rule 62 (term -> factor term_tail .)
    THEN            reduce using rule 62 (term -> factor term_tail .)
    SEMICOLON       reduce using rule 62 (term -> factor term_tail .)
    END             reduce using rule 62 (term -> factor term_tail .)
    ELSE            reduce using rule 62 (term -> factor term_tail .)
    COMMA           reduce using rule 62 (term -> factor term_tail .)
    RPAREN          reduce using rule 62 (term -> factor term_tail .)


state 88

    (63) term_tail -> TIMES . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    factor                         shift and go to state 118

state 89

    (64) term_tail -> DIVIDE . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    factor                         shift and go to state 119

state 90

    (65) term_tail -> REAL_DIVIDE . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    factor                         shift and go to state 120

state 91

    (66) term_tail -> empty .

    PLUS            reduce using rule 66 (term_tail -> empty .)
    MINUS           reduce using rule 66 (term_tail -> empty .)
    LT              reduce using rule 66 (term_tail -> empty .)
    GT              reduce using rule 66 (term_tail -> empty .)
    LE              reduce using rule 66 (term_tail -> empty .)
    GE              reduce using rule 66 (term_tail -> empty .)
    NE              reduce using rule 66 (term_tail -> empty .)
    EQUAL           reduce using rule 66 (term_tail -> empty .)
    AND             reduce using rule 66 (term_tail -> empty .)
    OR              reduce using rule 66 (term_tail -> empty .)
    THEN            reduce using rule 66 (term_tail -> empty .)
    SEMICOLON       reduce using rule 66 (term_tail -> empty .)
    END             reduce using rule 66 (term_tail -> empty .)
    ELSE            reduce using rule 66 (term_tail -> empty .)
    COMMA           reduce using rule 66 (term_tail -> empty .)
    RPAREN          reduce using rule 66 (term_tail -> empty .)


state 92

    (67) factor -> PLUS factor .

    TIMES           reduce using rule 67 (factor -> PLUS factor .)
    DIVIDE          reduce using rule 67 (factor -> PLUS factor .)
    REAL_DIVIDE     reduce using rule 67 (factor -> PLUS factor .)
    PLUS            reduce using rule 67 (factor -> PLUS factor .)
    MINUS           reduce using rule 67 (factor -> PLUS factor .)
    LT              reduce using rule 67 (factor -> PLUS factor .)
    GT              reduce using rule 67 (factor -> PLUS factor .)
    LE              reduce using rule 67 (factor -> PLUS factor .)
    GE              reduce using rule 67 (factor -> PLUS factor .)
    NE              reduce using rule 67 (factor -> PLUS factor .)
    EQUAL           reduce using rule 67 (factor -> PLUS factor .)
    AND             reduce using rule 67 (factor -> PLUS factor .)
    OR              reduce using rule 67 (factor -> PLUS factor .)
    THEN            reduce using rule 67 (factor -> PLUS factor .)
    SEMICOLON       reduce using rule 67 (factor -> PLUS factor .)
    END             reduce using rule 67 (factor -> PLUS factor .)
    ELSE            reduce using rule 67 (factor -> PLUS factor .)
    COMMA           reduce using rule 67 (factor -> PLUS factor .)
    RPAREN          reduce using rule 67 (factor -> PLUS factor .)


state 93

    (68) factor -> MINUS factor .

    TIMES           reduce using rule 68 (factor -> MINUS factor .)
    DIVIDE          reduce using rule 68 (factor -> MINUS factor .)
    REAL_DIVIDE     reduce using rule 68 (factor -> MINUS factor .)
    PLUS            reduce using rule 68 (factor -> MINUS factor .)
    MINUS           reduce using rule 68 (factor -> MINUS factor .)
    LT              reduce using rule 68 (factor -> MINUS factor .)
    GT              reduce using rule 68 (factor -> MINUS factor .)
    LE              reduce using rule 68 (factor -> MINUS factor .)
    GE              reduce using rule 68 (factor -> MINUS factor .)
    NE              reduce using rule 68 (factor -> MINUS factor .)
    EQUAL           reduce using rule 68 (factor -> MINUS factor .)
    AND             reduce using rule 68 (factor -> MINUS factor .)
    OR              reduce using rule 68 (factor -> MINUS factor .)
    THEN            reduce using rule 68 (factor -> MINUS factor .)
    SEMICOLON       reduce using rule 68 (factor -> MINUS factor .)
    END             reduce using rule 68 (factor -> MINUS factor .)
    ELSE            reduce using rule 68 (factor -> MINUS factor .)
    COMMA           reduce using rule 68 (factor -> MINUS factor .)
    RPAREN          reduce using rule 68 (factor -> MINUS factor .)


state 94

    (69) factor -> LPAREN expression . RPAREN
    (46) expression -> expression . OR and_expression

    RPAREN          shift and go to state 121
    OR              shift and go to state 98


state 95

    (7) vardecl -> idlist COLON type SEMICOLON .

    IDENTIFIER      reduce using rule 7 (vardecl -> idlist COLON type SEMICOLON .)
    BEGIN           reduce using rule 7 (vardecl -> idlist COLON type SEMICOLON .)


state 96

    (15) type -> ARRAY LBRACKET . INTEGER RBRACKET OF type

    INTEGER         shift and go to state 122


state 97

    (9) idlistTail -> COMMA IDENTIFIER idlistTail .

    COLON           reduce using rule 9 (idlistTail -> COMMA IDENTIFIER idlistTail .)


state 98

    (46) expression -> expression OR . and_expression
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    and_expression                 shift and go to state 106
    relation_expression            shift and go to state 44
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 99

    (40) write_statement -> LPAREN string_statement RPAREN .

    SEMICOLON       reduce using rule 40 (write_statement -> LPAREN string_statement RPAREN .)
    END             reduce using rule 40 (write_statement -> LPAREN string_statement RPAREN .)
    ELSE            reduce using rule 40 (write_statement -> LPAREN string_statement RPAREN .)


state 100

    (43) string_statement -> assign_expression COMMA . string_statement
    (42) string_statement -> . assign_expression
    (43) string_statement -> . assign_expression COMMA string_statement
    (44) assign_expression -> . expression
    (45) assign_expression -> . STRING
    (46) expression -> . expression OR and_expression
    (47) expression -> . and_expression
    (48) and_expression -> . and_expression AND relation_expression
    (49) and_expression -> . relation_expression
    (50) relation_expression -> . simple_expression expression_tail
    (58) simple_expression -> . term simple_expression_tail
    (62) term -> . factor term_tail
    (67) factor -> . PLUS factor
    (68) factor -> . MINUS factor
    (69) factor -> . LPAREN expression RPAREN
    (70) factor -> . INTEGER
    (71) factor -> . REAL
    (72) factor -> . IDENTIFIER

    STRING          shift and go to state 64
    PLUS            shift and go to state 48
    MINUS           shift and go to state 49
    LPAREN          shift and go to state 50
    INTEGER         shift and go to state 51
    REAL            shift and go to state 52
    IDENTIFIER      shift and go to state 53

    assign_expression              shift and go to state 66
    string_statement               shift and go to state 123
    expression                     shift and go to state 63
    and_expression                 shift and go to state 43
    relation_expression            shift and go to state 44
    simple_expression              shift and go to state 45
    term                           shift and go to state 46
    factor                         shift and go to state 47

state 101

    (41) readln_statement -> LPAREN string_statement RPAREN .

    SEMICOLON       reduce using rule 41 (readln_statement -> LPAREN string_statement RPAREN .)
    END             reduce using rule 41 (readln_statement -> LPAREN string_statement RPAREN .)
    ELSE            reduce using rule 41 (readln_statement -> LPAREN string_statement RPAREN .)


state 102

    (25) statement -> IF if_condition THEN if_code .

    SEMICOLON       reduce using rule 25 (statement -> IF if_condition THEN if_code .)
    END             reduce using rule 25 (statement -> IF if_condition THEN if_code .)
    ELSE            reduce using rule 25 (statement -> IF if_condition THEN if_code .)


state 103

    (28) if_code -> code . opt_else
    (31) opt_else -> . ELSE code_or_statement
    (32) opt_else -> . empty
    (73) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 125
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)

  ! ELSE            [ reduce using rule 73 (empty -> .) ]

    opt_else                       shift and go to state 124
    empty                          shift and go to state 126

state 104

    (29) if_code -> statement . opt_else
    (31) opt_else -> . ELSE code_or_statement
    (32) opt_else -> . empty
    (73) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 125
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)

  ! ELSE            [ reduce using rule 73 (empty -> .) ]

    opt_else                       shift and go to state 127
    empty                          shift and go to state 126

state 105

    (30) if_code -> empty .

    ELSE            reduce using rule 30 (if_code -> empty .)
    SEMICOLON       reduce using rule 30 (if_code -> empty .)
    END             reduce using rule 30 (if_code -> empty .)


state 106

    (46) expression -> expression OR and_expression .
    (48) and_expression -> and_expression . AND relation_expression

  ! shift/reduce conflict for AND resolved as shift
    OR              reduce using rule 46 (expression -> expression OR and_expression .)
    THEN            reduce using rule 46 (expression -> expression OR and_expression .)
    SEMICOLON       reduce using rule 46 (expression -> expression OR and_expression .)
    END             reduce using rule 46 (expression -> expression OR and_expression .)
    ELSE            reduce using rule 46 (expression -> expression OR and_expression .)
    COMMA           reduce using rule 46 (expression -> expression OR and_expression .)
    RPAREN          reduce using rule 46 (expression -> expression OR and_expression .)
    AND             shift and go to state 74

  ! AND             [ reduce using rule 46 (expression -> expression OR and_expression .) ]


state 107

    (36) if_condition_tail -> OR if_condition_tail_2 .

    THEN            reduce using rule 36 (if_condition_tail -> OR if_condition_tail_2 .)


state 108

    (38) if_condition_tail_2 -> AND if_condition .

    THEN            reduce using rule 38 (if_condition_tail_2 -> AND if_condition .)


state 109

    (48) and_expression -> and_expression AND relation_expression .

    AND             reduce using rule 48 (and_expression -> and_expression AND relation_expression .)
    OR              reduce using rule 48 (and_expression -> and_expression AND relation_expression .)
    THEN            reduce using rule 48 (and_expression -> and_expression AND relation_expression .)
    SEMICOLON       reduce using rule 48 (and_expression -> and_expression AND relation_expression .)
    END             reduce using rule 48 (and_expression -> and_expression AND relation_expression .)
    ELSE            reduce using rule 48 (and_expression -> and_expression AND relation_expression .)
    COMMA           reduce using rule 48 (and_expression -> and_expression AND relation_expression .)
    RPAREN          reduce using rule 48 (and_expression -> and_expression AND relation_expression .)


state 110

    (51) expression_tail -> LT simple_expression .

    AND             reduce using rule 51 (expression_tail -> LT simple_expression .)
    OR              reduce using rule 51 (expression_tail -> LT simple_expression .)
    THEN            reduce using rule 51 (expression_tail -> LT simple_expression .)
    SEMICOLON       reduce using rule 51 (expression_tail -> LT simple_expression .)
    END             reduce using rule 51 (expression_tail -> LT simple_expression .)
    ELSE            reduce using rule 51 (expression_tail -> LT simple_expression .)
    COMMA           reduce using rule 51 (expression_tail -> LT simple_expression .)
    RPAREN          reduce using rule 51 (expression_tail -> LT simple_expression .)


state 111

    (52) expression_tail -> GT simple_expression .

    AND             reduce using rule 52 (expression_tail -> GT simple_expression .)
    OR              reduce using rule 52 (expression_tail -> GT simple_expression .)
    THEN            reduce using rule 52 (expression_tail -> GT simple_expression .)
    SEMICOLON       reduce using rule 52 (expression_tail -> GT simple_expression .)
    END             reduce using rule 52 (expression_tail -> GT simple_expression .)
    ELSE            reduce using rule 52 (expression_tail -> GT simple_expression .)
    COMMA           reduce using rule 52 (expression_tail -> GT simple_expression .)
    RPAREN          reduce using rule 52 (expression_tail -> GT simple_expression .)


state 112

    (53) expression_tail -> LE simple_expression .

    AND             reduce using rule 53 (expression_tail -> LE simple_expression .)
    OR              reduce using rule 53 (expression_tail -> LE simple_expression .)
    THEN            reduce using rule 53 (expression_tail -> LE simple_expression .)
    SEMICOLON       reduce using rule 53 (expression_tail -> LE simple_expression .)
    END             reduce using rule 53 (expression_tail -> LE simple_expression .)
    ELSE            reduce using rule 53 (expression_tail -> LE simple_expression .)
    COMMA           reduce using rule 53 (expression_tail -> LE simple_expression .)
    RPAREN          reduce using rule 53 (expression_tail -> LE simple_expression .)


state 113

    (54) expression_tail -> GE simple_expression .

    AND             reduce using rule 54 (expression_tail -> GE simple_expression .)
    OR              reduce using rule 54 (expression_tail -> GE simple_expression .)
    THEN            reduce using rule 54 (expression_tail -> GE simple_expression .)
    SEMICOLON       reduce using rule 54 (expression_tail -> GE simple_expression .)
    END             reduce using rule 54 (expression_tail -> GE simple_expression .)
    ELSE            reduce using rule 54 (expression_tail -> GE simple_expression .)
    COMMA           reduce using rule 54 (expression_tail -> GE simple_expression .)
    RPAREN          reduce using rule 54 (expression_tail -> GE simple_expression .)


state 114

    (55) expression_tail -> NE simple_expression .

    AND             reduce using rule 55 (expression_tail -> NE simple_expression .)
    OR              reduce using rule 55 (expression_tail -> NE simple_expression .)
    THEN            reduce using rule 55 (expression_tail -> NE simple_expression .)
    SEMICOLON       reduce using rule 55 (expression_tail -> NE simple_expression .)
    END             reduce using rule 55 (expression_tail -> NE simple_expression .)
    ELSE            reduce using rule 55 (expression_tail -> NE simple_expression .)
    COMMA           reduce using rule 55 (expression_tail -> NE simple_expression .)
    RPAREN          reduce using rule 55 (expression_tail -> NE simple_expression .)


state 115

    (56) expression_tail -> EQUAL simple_expression .

    AND             reduce using rule 56 (expression_tail -> EQUAL simple_expression .)
    OR              reduce using rule 56 (expression_tail -> EQUAL simple_expression .)
    THEN            reduce using rule 56 (expression_tail -> EQUAL simple_expression .)
    SEMICOLON       reduce using rule 56 (expression_tail -> EQUAL simple_expression .)
    END             reduce using rule 56 (expression_tail -> EQUAL simple_expression .)
    ELSE            reduce using rule 56 (expression_tail -> EQUAL simple_expression .)
    COMMA           reduce using rule 56 (expression_tail -> EQUAL simple_expression .)
    RPAREN          reduce using rule 56 (expression_tail -> EQUAL simple_expression .)


state 116

    (59) simple_expression_tail -> PLUS term . simple_expression_tail
    (59) simple_expression_tail -> . PLUS term simple_expression_tail
    (60) simple_expression_tail -> . MINUS term simple_expression_tail
    (61) simple_expression_tail -> . empty
    (73) empty -> .

    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    LT              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    NE              reduce using rule 73 (empty -> .)
    EQUAL           reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    THEN            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)
    ELSE            reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    simple_expression_tail         shift and go to state 128
    empty                          shift and go to state 86

state 117

    (60) simple_expression_tail -> MINUS term . simple_expression_tail
    (59) simple_expression_tail -> . PLUS term simple_expression_tail
    (60) simple_expression_tail -> . MINUS term simple_expression_tail
    (61) simple_expression_tail -> . empty
    (73) empty -> .

    PLUS            shift and go to state 84
    MINUS           shift and go to state 85
    LT              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    NE              reduce using rule 73 (empty -> .)
    EQUAL           reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    THEN            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)
    ELSE            reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    simple_expression_tail         shift and go to state 129
    empty                          shift and go to state 86

state 118

    (63) term_tail -> TIMES factor . term_tail
    (63) term_tail -> . TIMES factor term_tail
    (64) term_tail -> . DIVIDE factor term_tail
    (65) term_tail -> . REAL_DIVIDE factor term_tail
    (66) term_tail -> . empty
    (73) empty -> .

    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    REAL_DIVIDE     shift and go to state 90
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    NE              reduce using rule 73 (empty -> .)
    EQUAL           reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    THEN            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)
    ELSE            reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    term_tail                      shift and go to state 130
    empty                          shift and go to state 91

state 119

    (64) term_tail -> DIVIDE factor . term_tail
    (63) term_tail -> . TIMES factor term_tail
    (64) term_tail -> . DIVIDE factor term_tail
    (65) term_tail -> . REAL_DIVIDE factor term_tail
    (66) term_tail -> . empty
    (73) empty -> .

    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    REAL_DIVIDE     shift and go to state 90
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    NE              reduce using rule 73 (empty -> .)
    EQUAL           reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    THEN            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)
    ELSE            reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    term_tail                      shift and go to state 131
    empty                          shift and go to state 91

state 120

    (65) term_tail -> REAL_DIVIDE factor . term_tail
    (63) term_tail -> . TIMES factor term_tail
    (64) term_tail -> . DIVIDE factor term_tail
    (65) term_tail -> . REAL_DIVIDE factor term_tail
    (66) term_tail -> . empty
    (73) empty -> .

    TIMES           shift and go to state 88
    DIVIDE          shift and go to state 89
    REAL_DIVIDE     shift and go to state 90
    PLUS            reduce using rule 73 (empty -> .)
    MINUS           reduce using rule 73 (empty -> .)
    LT              reduce using rule 73 (empty -> .)
    GT              reduce using rule 73 (empty -> .)
    LE              reduce using rule 73 (empty -> .)
    GE              reduce using rule 73 (empty -> .)
    NE              reduce using rule 73 (empty -> .)
    EQUAL           reduce using rule 73 (empty -> .)
    AND             reduce using rule 73 (empty -> .)
    OR              reduce using rule 73 (empty -> .)
    THEN            reduce using rule 73 (empty -> .)
    SEMICOLON       reduce using rule 73 (empty -> .)
    END             reduce using rule 73 (empty -> .)
    ELSE            reduce using rule 73 (empty -> .)
    COMMA           reduce using rule 73 (empty -> .)
    RPAREN          reduce using rule 73 (empty -> .)

    term_tail                      shift and go to state 132
    empty                          shift and go to state 91

state 121

    (69) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    REAL_DIVIDE     reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    LT              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    GT              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    LE              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    GE              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    NE              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    THEN            reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    END             reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    ELSE            reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 69 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 69 (factor -> LPAREN expression RPAREN .)


state 122

    (15) type -> ARRAY LBRACKET INTEGER . RBRACKET OF type

    RBRACKET        shift and go to state 133


state 123

    (43) string_statement -> assign_expression COMMA string_statement .

    RPAREN          reduce using rule 43 (string_statement -> assign_expression COMMA string_statement .)


state 124

    (28) if_code -> code opt_else .

    ELSE            reduce using rule 28 (if_code -> code opt_else .)
    SEMICOLON       reduce using rule 28 (if_code -> code opt_else .)
    END             reduce using rule 28 (if_code -> code opt_else .)


state 125

    (31) opt_else -> ELSE . code_or_statement
    (33) code_or_statement -> . code
    (34) code_or_statement -> . statement
    (16) code -> . BEGIN expressions END
    (21) statement -> . IDENTIFIER ASSIGN assign_expression
    (22) statement -> . WRITELN write_statement
    (23) statement -> . WRITE write_statement
    (24) statement -> . READLN readln_statement
    (25) statement -> . IF if_condition THEN if_code
    (26) statement -> . FOR
    (27) statement -> . WHILE

    BEGIN           shift and go to state 10
    IDENTIFIER      shift and go to state 19
    WRITELN         shift and go to state 20
    WRITE           shift and go to state 21
    READLN          shift and go to state 22
    IF              shift and go to state 23
    FOR             shift and go to state 24
    WHILE           shift and go to state 25

    code_or_statement              shift and go to state 134
    code                           shift and go to state 135
    statement                      shift and go to state 136

state 126

    (32) opt_else -> empty .

    ELSE            reduce using rule 32 (opt_else -> empty .)
    SEMICOLON       reduce using rule 32 (opt_else -> empty .)
    END             reduce using rule 32 (opt_else -> empty .)


state 127

    (29) if_code -> statement opt_else .

    ELSE            reduce using rule 29 (if_code -> statement opt_else .)
    SEMICOLON       reduce using rule 29 (if_code -> statement opt_else .)
    END             reduce using rule 29 (if_code -> statement opt_else .)


state 128

    (59) simple_expression_tail -> PLUS term simple_expression_tail .

    LT              reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    GT              reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    LE              reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    GE              reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    NE              reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    EQUAL           reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    AND             reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    OR              reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    THEN            reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    SEMICOLON       reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    END             reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    ELSE            reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    COMMA           reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)
    RPAREN          reduce using rule 59 (simple_expression_tail -> PLUS term simple_expression_tail .)


state 129

    (60) simple_expression_tail -> MINUS term simple_expression_tail .

    LT              reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    GT              reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    LE              reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    GE              reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    NE              reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    EQUAL           reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    AND             reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    OR              reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    THEN            reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    SEMICOLON       reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    END             reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    ELSE            reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    COMMA           reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)
    RPAREN          reduce using rule 60 (simple_expression_tail -> MINUS term simple_expression_tail .)


state 130

    (63) term_tail -> TIMES factor term_tail .

    PLUS            reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    MINUS           reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    LT              reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    GT              reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    LE              reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    GE              reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    NE              reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    EQUAL           reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    AND             reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    OR              reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    THEN            reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    SEMICOLON       reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    END             reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    ELSE            reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    COMMA           reduce using rule 63 (term_tail -> TIMES factor term_tail .)
    RPAREN          reduce using rule 63 (term_tail -> TIMES factor term_tail .)


state 131

    (64) term_tail -> DIVIDE factor term_tail .

    PLUS            reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    MINUS           reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    LT              reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    GT              reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    LE              reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    GE              reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    NE              reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    EQUAL           reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    AND             reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    OR              reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    THEN            reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    SEMICOLON       reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    END             reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    ELSE            reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    COMMA           reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)
    RPAREN          reduce using rule 64 (term_tail -> DIVIDE factor term_tail .)


state 132

    (65) term_tail -> REAL_DIVIDE factor term_tail .

    PLUS            reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    MINUS           reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    LT              reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    GT              reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    LE              reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    GE              reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    NE              reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    EQUAL           reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    AND             reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    OR              reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    THEN            reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    SEMICOLON       reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    END             reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    ELSE            reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    COMMA           reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)
    RPAREN          reduce using rule 65 (term_tail -> REAL_DIVIDE factor term_tail .)


state 133

    (15) type -> ARRAY LBRACKET INTEGER RBRACKET . OF type

    OF              shift and go to state 137


state 134

    (31) opt_else -> ELSE code_or_statement .

    ELSE            reduce using rule 31 (opt_else -> ELSE code_or_statement .)
    SEMICOLON       reduce using rule 31 (opt_else -> ELSE code_or_statement .)
    END             reduce using rule 31 (opt_else -> ELSE code_or_statement .)


state 135

    (33) code_or_statement -> code .

    ELSE            reduce using rule 33 (code_or_statement -> code .)
    SEMICOLON       reduce using rule 33 (code_or_statement -> code .)
    END             reduce using rule 33 (code_or_statement -> code .)


state 136

    (34) code_or_statement -> statement .

    ELSE            reduce using rule 34 (code_or_statement -> statement .)
    SEMICOLON       reduce using rule 34 (code_or_statement -> statement .)
    END             reduce using rule 34 (code_or_statement -> statement .)


state 137

    (15) type -> ARRAY LBRACKET INTEGER RBRACKET OF . type
    (11) type -> . TYPE_INTEGER
    (12) type -> . TYPE_REAL
    (13) type -> . BOOLEAN
    (14) type -> . TYPE_STRING
    (15) type -> . ARRAY LBRACKET INTEGER RBRACKET OF type

    TYPE_INTEGER    shift and go to state 55
    TYPE_REAL       shift and go to state 56
    BOOLEAN         shift and go to state 57
    TYPE_STRING     shift and go to state 58
    ARRAY           shift and go to state 59

    type                           shift and go to state 138

state 138

    (15) type -> ARRAY LBRACKET INTEGER RBRACKET OF type .

    SEMICOLON       reduce using rule 15 (type -> ARRAY LBRACKET INTEGER RBRACKET OF type .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for AND in state 43 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 103 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 104 resolved as shift
WARNING: shift/reduce conflict for AND in state 106 resolved as shift
